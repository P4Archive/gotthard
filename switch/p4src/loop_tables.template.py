import argparse

tmpl_t_handle_write = lambda idx: """
table t_handle_write%i {
    actions {
        do_handle_write%i;
    }
    size: 1;
}
""".replace('%i', str(idx))

tmpl_t_bad_compare = lambda idx: """
table t_bad_compare%i {
    actions {
        do_bad_compare%i;
    }
    size: 1;
}
""".replace('%i', str(idx))

tmpl_t_bad_opti_compare = lambda idx: """
table t_bad_opti_compare%i {
    actions {
        do_bad_opti_compare%i;
    }
    size: 1;
}
""".replace('%i', str(idx))

tmpl_t_delete_op = lambda idx: """
table t_delete_op%i {
    actions {
        do_delete_op%i;
    }
    size: 1;
}
""".replace('%i', str(idx))

tmpl_t_store_update = lambda cnt: """
table t_store_update {
    reads {
        gotthard_hdr.op_cnt: exact;
    }
    actions {
        _nop;
        %s
    }
    size: %d;
}
""" % (('\n' + ' ' * 8).join(['do_store_update%d;'%i for i in xrange(cnt)]), cnt+1)

tmpl_t_satisfy_read = lambda idx: """
table t_satisfy_read%i {
    actions {
        do_satisfy_read%i;
    }
    size: 1;
}
""".replace('%i', str(idx))

tmpl_do_handle_write = lambda idx: """
action do_handle_write%i() {
    is_opti_cached_register[gotthard_op[%i].key] = 1;
    is_cached_register[gotthard_op[%i].key] = 0;
    opti_value_register[gotthard_op[%i].key] = gotthard_op[%i].value;
}
""".replace('%i', str(idx))

tmpl_do_bad_compare = lambda idx: """
action do_bad_compare%i() {
    req_meta.has_bad_compare = 1;
    gotthard_op[%i].op_type = GOTTHARD_OP_VALUE;
    gotthard_op[%i].value = value_register[gotthard_op[%i].key];
}
""".replace('%i', str(idx))

tmpl_do_bad_opti_compare = lambda idx: """
action do_bad_opti_compare%i() {
    req_meta.has_bad_opti_compare = 1;
    gotthard_op[%i].op_type = GOTTHARD_OP_VALUE;
    gotthard_op[%i].value = opti_value_register[gotthard_op[%i].key];
}
""".replace('%i', str(idx))

tmpl_do_delete_op = lambda idx: """
action do_delete_op%i() {
    gotthard_op[%i].op_type = GOTTHARD_OP_NOP;
}
""".replace('%i', str(idx))


tmpl_do_store_update = lambda idx: """
action do_store_update%i() {
    %prev
    value_register[gotthard_op[%i].key] = gotthard_op[%i].value;
    is_cached_register[gotthard_op[%i].key] = 1;
    // clear if this is an abort:
    is_opti_cached_register[gotthard_op[%i].key] = (((bit<1>)gotthard_hdr.status) ^ 1) & is_opti_cached_register[gotthard_op[%i].key];
}
""".replace('%i', str(idx)).replace('%prev', '' if idx == 0 else 'do_store_update%d();'%(idx-1))

tmpl_do_satisfy_read = lambda idx: """
action do_satisfy_read%i() {
    gotthard_op[%i].op_type = GOTTHARD_OP_VALUE;
    gotthard_op[%i].value = value_register[gotthard_op[%i].key];
}
""".replace('%i', str(idx))

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Gotthard P4 source code generation')
    parser.add_argument('--max-op', '-m', help='Number of TXN ops to support',
                    type=int, action="store", required=True)
    args = parser.parse_args()
    cnt = args.max_op

    out = "// !!! Autogenerated code !!!\n\n"

    out += "#define GOTTHARD_MAX_OP %d\n" % cnt

    out += '\n'.join(map(tmpl_do_handle_write, xrange(cnt)))
    out += '\n'.join(map(tmpl_t_handle_write, xrange(cnt)))

    out += '\n'.join(map(tmpl_do_store_update, xrange(cnt)))
    out += tmpl_t_store_update(cnt)

    out += '\n'.join(map(tmpl_do_bad_compare, xrange(cnt)))
    out += '\n'.join(map(tmpl_t_bad_compare, xrange(cnt)))

    out += '\n'.join(map(tmpl_do_bad_opti_compare, xrange(cnt)))
    out += '\n'.join(map(tmpl_t_bad_opti_compare, xrange(cnt)))

    out += '\n'.join(map(tmpl_do_delete_op, xrange(cnt)))
    out += '\n'.join(map(tmpl_t_delete_op, xrange(cnt)))

    out += '\n'.join(map(tmpl_do_satisfy_read, xrange(cnt)))
    out += '\n'.join(map(tmpl_t_satisfy_read, xrange(cnt)))

    print out
